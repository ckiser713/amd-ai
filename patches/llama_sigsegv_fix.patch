--- a/tools/server/server-models.cpp
+++ b/tools/server/server-models.cpp
@@ -85,16 +85,35 @@ server_models::server_models(
         const common_params & params,
         int argc,
         char ** argv,
         char ** envp) : base_params(params) {
-    // Direct dereference - CRASHES if argv/envp is null!
-    for (int i = 0; i < argc; i++) {
-        base_args.push_back(argv[i]);  // SIGSEGV here
-    }
-    for (char ** env = envp; *env != nullptr; env++) {
-        base_env.push_back(std::string(*env));  // SIGSEGV here
+    // Defensive: Copy argv safely
+    if (argv != nullptr) {
+        for (int i = 0; i < argc; i++) {
+            base_args.push_back(argv[i] ? std::string(argv[i]) : std::string());
+        }
+    } else {
+        LOG_WRN("server_models: argv is null, continuing with empty base_args\n");
+    }
+
+    // Defensive: Copy envp safely
+    if (envp != nullptr) {
+        for (char ** env = envp; *env != nullptr; env++) {
+            if (*env != nullptr) {
+                base_env.push_back(std::string(*env));
+            } else {
+                LOG_WRN("server_models: encountered null entry in envp, skipping\n");
+            }
+        }
+    } else {
+        LOG_WRN("server_models: envp is null, continuing without base_env\n");
+    }
+    
+    // Fallback if base_args is empty
+    GGML_ASSERT(!base_args.empty());
+    
+    // Safe fallback path resolution
+    try {
+        base_args[0] = get_server_exec_path().string();
+    } catch (const std::exception & e) {
+        LOG_WRN("failed to get server executable path: %s\n", e.what());
+        LOG_WRN("using original argv[0] as fallback: %s\n", base_args[0].c_str());
     }
 }
