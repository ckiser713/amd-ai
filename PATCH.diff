--- a/tools/server/server-models.cpp
+++ b/tools/server/server-models.cpp
@@ -135,20 +135,53 @@ static std::vector<local_model> list_local_models(const std::string & dir) {
 server_models::server_models(
         const common_params & params,
         int argc,
         char ** argv,
         char ** envp) : base_params(params) {
-    // copy argv
+    // copy argv safely (defensive: some embedder/launchers may pass nullptr)
+    if (argv != nullptr) {
+        for (int i = 0; i < argc; i++) {
+            base_args.push_back(argv[i] ? std::string(argv[i]) : std::string());
+        }
+    } else {
+        // fallback: empty argv, will try to resolve executable path later
+        LOG_WRN("server_models: argv is null, continuing with empty base_args\n");
+    }
+
+    // copy envp safely: envp may be null in some environments
+    if (envp != nullptr) {
+        for (char ** env = envp; *env != nullptr; env++) {
+            if (*env != nullptr) {
+                base_env.push_back(std::string(*env));
+            } else {
+                // skip null entries defensively
+                LOG_WRN("server_models: encountered null entry in envp, skipping\n");
+            }
+        }
+    } else {
+        LOG_WRN("server_models: envp is null, continuing without base_env\n");
+    }
+    GGML_ASSERT(!base_args.empty());
+    // set binary path
+    try {
+        base_args[0] = get_server_exec_path().string();
+    } catch (const std::exception & e) {
+        LOG_WRN("failed to get server executable path: %s\n", e.what());
+        LOG_WRN("using original argv[0] as fallback: %s\n", base_args[0].c_str());
+    }
     // TODO: allow refreshing cached model list
     // add cached models
     auto cached_models = common_list_cached_models();
     for (const auto & model : cached_models) {
         server_model_meta meta{
             /* name        */ model.to_string(),
             /* path        */ model.manifest_path,
             /* path_mmproj */ "", // auto-detected when loading
             /* in_cache    */ true,
             /* port        */ 0,
             /* status      */ SERVER_MODEL_STATUS_UNLOADED,
             /* last_used   */ 0,
             /* args        */ std::vector<std::string>(),
             /* exit_code   */ 0
         };
         mapping[meta.name] = instance_t{
             /* subproc */ std::make_shared<subprocess_s>(),
             /* th      */ std::thread(),
             /* meta    */ meta
         };
     }
